//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------
// NOTE by default, chuginate generates a new UGen subclass in this file
//      but it is possible, of course, to create non-UGen classes in a chugin!
// To modify this generated file for a non-UGen class...
//      1. in QUERY->begin_class(), change "UGen" to a different ChucK class
//         (e.g., `QUERY->begin_class(QUERY, "SADN", "Object");`)
//      2. remove or commment out the line containing QUERY->add_ugen_func()
//      3. that's it; the rest is no different for UGens/non-UGens
//-----------------------------------------------------------------------------
// NOTE once you have built this into a chugin (SADN.chug), here are a few
//      helpful tools for testing / probing / verifying your new chugin!
//
// chuginate also generated a SADN-test.ck boilerplate ChucK program
//      to help test your chugin (see SADN-test.ck for more instructions)
//
// run `chuck --chugin-probe` to probe what chugins would be loaded, and
//      from where in the chugin search paths
//
// run `chuck -v3 --loop` to see what chugins are actually loaded at runtime,
//      with more info and error reporting than with --chugin-probe
//
// other helpful chugin-related flags include:
//      --chugin:<filename>
//      --chugin-path:(path) / -G(path)
//      --chugin-load:{on/off}
//
// for more information on command-line options:
//      https://chuck.stanford.edu/doc/program/options.html
// for more information on chugins:
//      https://chuck.stanford.edu/extend/
//-----------------------------------------------------------------------------
// happy chucking & chugging!
//-----------------------------------------------------------------------------

// include chugin header
#include "chugin.h"
#include "chuckSH.h"
#include "SADN.h"

// general includes
#include <iostream>

// SAD1 function defs
CK_DLL_CTOR( sad1_ctor );
CK_DLL_DTOR( sad1_dtor );
CK_DLL_MFUN(sad1_setSpeakers);
CK_DLL_MFUN(sad1_getSpeakers);
CK_DLL_TICKF( sad1_tickf );

// this is a special offset reserved for chugin internal data
t_CKINT sad1_data_offset = 0;

//-----------------------------------------------------------------------------
// class definition for internal chugin data
// (NOTE this isn't strictly necessary, but is one example of a recommended approach)
//-----------------------------------------------------------------------------
class SAD1 : public SADN<1>
{
public:

    SAD1(t_CKFLOAT fs) {};

    void setSpeakers(Chuck_Object* coord, CK_DL_API API)
    {
        Chuck_ArrayInt* column = (Chuck_ArrayInt*)coord;
        for (t_CKINT i = 0; i < API->object->array_int_size(column); i++)
        {
            Chuck_ArrayFloat* row = (Chuck_ArrayFloat*)API->object->array_int_get_idx(column, i);
            t_CKUINT size = API->object->array_float_size(row);
            if (size == 2)
            {
                std::vector<float> temp = SH(1, API->object->array_float_get_idx(row, 0), API->object->array_float_get_idx(row, 1), 0);
                for (int j = 0; j < temp.size(); j++)
                {
                    SpeakSH[i][j] = temp[j];
                }
            }
        }
    }

    // set parameter example
    t_CKFLOAT setParam( t_CKFLOAT p )
    {
        m_param = p;
        return p;
    }

    // get parameter example
    t_CKFLOAT getParam() { return m_param; }
    
private:
    // instance data
    t_CKFLOAT m_param = 0.f;
};


//-----------------------------------------------------------------------------
// info function: ChucK calls this when loading/probing the chugin
// NOTE: please customize these info fields below; they will be used for
// chugins loading, probing, and package management and documentation
//-----------------------------------------------------------------------------
CK_DLL_INFO( SAD )
{
    // the version string of this chugin, e.g., "v1.2.1"
    QUERY->setinfo( QUERY, CHUGIN_INFO_CHUGIN_VERSION, "" );
    // the author(s) of this chugin, e.g., "Alice Baker & Carl Donut"
    QUERY->setinfo( QUERY, CHUGIN_INFO_AUTHORS, "" );
    // text description of this chugin; what is it? what does it do? who is it for?
    QUERY->setinfo( QUERY, CHUGIN_INFO_DESCRIPTION, "" );
    // (optional) URL of the homepage for this chugin
    QUERY->setinfo( QUERY, CHUGIN_INFO_URL, "" );
    // (optional) contact email
    QUERY->setinfo( QUERY, CHUGIN_INFO_EMAIL, "" );
}


//-----------------------------------------------------------------------------
// query function: ChucK calls this when loading the chugin
// modify this function to define this chugin's API and language extensions
//-----------------------------------------------------------------------------
CK_DLL_QUERY( SAD )
{
    // generally, don't change this...
    QUERY->setname( QUERY, "SAD" );

    // ------------------------------------------------------------------------
    // begin class definition(s); will be compiled, verified,
    // and added to the chuck host type system for use
    // ------------------------------------------------------------------------
    // NOTE to create a non-UGen class, change the second argument
    // to extend a different ChucK class (e.g., "Object")
    QUERY->begin_class( QUERY, "SAD1", "UGen" );
    QUERY->add_ctor( QUERY, sad1_ctor );
    QUERY->add_dtor( QUERY, sad1_dtor );
    QUERY->add_ugen_funcf( QUERY, sad1_tickf, NULL, 4, 4 );
    QUERY->add_mfun(QUERY, sad1_setSpeakers, "void", "placement");
    QUERY->add_arg(QUERY, "float[][]", "");
    QUERY->add_mfun(QUERY, sad1_getSpeakers, "float[][]", "placement");
        
    // this reserves a variable in the ChucK internal class to store 
    // referene to the c++ class we defined above
    sad1_data_offset = QUERY->add_mvar( QUERY, "int", "@sad1_data", false );

    // ------------------------------------------------------------------------
    // end the class definition
    // IMPORTANT: this MUST be called to each class definition!
    // ------------------------------------------------------------------------
    QUERY->end_class( QUERY );

    // wasn't that a breeze?
    return TRUE;
}

//=================================================//
// ************************************************//
//                                                 //   
// SAD1 DLL definitions ; Everett M. Carpenter  //
//                                                 //
// ************************************************//
//=================================================//
// implementation for the default constructor

// implementation for the default constructor
CK_DLL_CTOR(sad1_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, sad1_data_offset) = 0;
    // instantiate our internal c++ class representation
    SAD1* sad1_obj = new SAD1(API->vm->srate(VM));
    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, sad1_data_offset) = (t_CKINT)sad1_obj;
}

// implementation for the destructor
CK_DLL_DTOR( sad1_dtor )
{
    // get our c++ class pointer
    SAD1 * sad1_obj = (SAD1 *)OBJ_MEMBER_INT( SELF, sad1_data_offset );
    // clean up (this macro tests for NULL, deletes, and zeros out the variable)
    CK_SAFE_DELETE( sad1_obj );
    // set the data field to 0
    OBJ_MEMBER_INT( SELF, sad1_data_offset ) = 0;
}

// implementation for tick function (relevant only for UGens)
CK_DLL_TICKF(sad1_tickf)
{
    // get our c++ class pointer
    SAD1 * sad1_obj = (SAD1 *)OBJ_MEMBER_INT(SELF, sad1_data_offset);
    if( sad1_obj ) sad1_obj->tick(in, out, nframes);
    // yes
    return TRUE;
}

CK_DLL_MFUN(sad1_setSpeakers)
{
    Chuck_Object* multi_array = GET_NEXT_OBJECT(ARGS);
    // get our c++ class pointer
    SAD1* sad1_obj = (SAD1*)OBJ_MEMBER_INT(SELF, sad1_data_offset);
    if (sad1_obj) 
    { 
        sad1_obj->setSpeakers(multi_array, API); 
    }
}

CK_DLL_MFUN(sad1_getSpeakers)
{
    Chuck_Object* multi_array = GET_NEXT_OBJECT(ARGS);
    // get our c++ class pointer
    SAD1* sad1_obj = (SAD1*)OBJ_MEMBER_INT(SELF, sad1_data_offset);

    std::vector<std::vector<float>> sphericals = sad1_obj->getSpeakerSH();

    // create [][]
    Chuck_DL_Api::Object final = API->object->create(SHRED, API->type->lookup(VM, "float[][]"), false); // create idea of float[][]
    Chuck_ArrayInt* column = (Chuck_ArrayInt*)final; // cast to int array

    for (int i = 0; i < sphericals.capacity(); i++) // snatched from Line
    {
        Chuck_DL_Api::Object target_tmp = API->object->create(SHRED, API->type->lookup(VM, "float[]"), false); // create idea of float[]
        Chuck_ArrayFloat* row_tmp = (Chuck_ArrayFloat*)target_tmp; // cast to float array

        for (int j = 0; j < sphericals.size(); j++) 
        {
            API->object->array_float_push_back(row_tmp, sphericals[i][j]);
        }

        API->object->array_int_push_back(column, (t_CKINT)row_tmp); // push back the previously created float array 
    }

    RETURN->v_object = (Chuck_Object*)final;
}