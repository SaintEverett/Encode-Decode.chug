//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------
// NOTE by default, chuginate generates a new UGen subclass in this file
//      but it is possible, of course, to create non-UGen classes in a chugin!
// To modify this generated file for a non-UGen class...
//      1. in QUERY->begin_class(), change "UGen" to a different ChucK class
//         (e.g., `QUERY->begin_class(QUERY, "Encode", "Object");`)
//      2. remove or commment out the line containing QUERY->add_ugen_func()
//      3. that's it; the rest is no different for UGens/non-UGens
//-----------------------------------------------------------------------------
// NOTE once you have built this into a chugin (Encode.chug), here are a few
//      helpful tools for testing / probing / verifying your new chugin!
//
// chuginate also generated a Encode-test.ck boilerplate ChucK program
//      to help test your chugin (see Encode-test.ck for more instructions)
//
// run `chuck --chugin-probe` to probe what chugins would be loaded, and
//      from where in the chugin search paths
//
// run `chuck -v3 --loop` to see what chugins are actually loaded at runtime,
//      with more info and error reporting than with --chugin-probe
//
// other helpful chugin-related flags include:
//      --chugin:<filename>
//      --chugin-path:(path) / -G(path)
//      --chugin-load:{on/off}
//
// for more information on command-line options:
//      https://chuck.stanford.edu/doc/program/options.html
// for more information on chugins:
//      https://chuck.stanford.edu/extend/
//-----------------------------------------------------------------------------
// happy chucking & chugging!
//-----------------------------------------------------------------------------

// include chugin header
#include "chugin.h"

// general includes
#include <stdio.h>
#include <limits.h>
#include <math.h>


// declaration of chugin constructor
CK_DLL_CTOR( encode_ctor );
// declaration of chugin desctructor
CK_DLL_DTOR( encode_dtor );

// example of getter/setter
CK_DLL_MFUN( encode_setParam );
CK_DLL_MFUN( encode_getParam );

// for chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK( encode_tick );

// this is a special offset reserved for chugin internal data
t_CKINT encode_data_offset = 0;


//-----------------------------------------------------------------------------
// class definition for internal chugin data
// (NOTE this isn't strictly necessary, but is one example of a recommended approach)
//-----------------------------------------------------------------------------
class EncodeN
{
public:
    EncodeN(t_CKFLOAT fs, t_CKINT channels)
    {
        outCount = channels;
        channel_matrix = new t_CKFLOAT[outCount];
    }
    // for chugins extending UGen
    SAMPLE tickf( SAMPLE in, SAMPLE out, t_CKINT channel)
    {
        // default: this passes whatever input is patched into chugin
        out = in * channel_matrix[channel];
        return out;
    }
    // get parameter example
    t_CKINT getOrder() { return order; }
    // recieve and set coefficients

protected:
    // instance data
    t_CKFLOAT* channel_matrix;
    t_CKINT outCount = 0;
    t_CKINT order = 0; 
};

class Encode1 : public EncodeN
{
public:
    Encode1(t_CKFLOAT fs) : EncodeN(fs,4)
    {
        ;
    }   
};

class Encode2 : public EncodeN
{
public:
    Encode2(t_CKFLOAT fs) : EncodeN(fs,9)
    {
        ;
    }
};

class Encode3 : public EncodeN
{
public:
    Encode3(t_CKFLOAT fs) : EncodeN(fs,16)
    {
        ;
    }
};

class Encode4 : public EncodeN
{
public:
    Encode4(t_CKFLOAT fs) : EncodeN(fs,25)
    {
        ;
    }
};

class Encode5 : public EncodeN
{
public:
    Encode5(t_CKFLOAT fs) : EncodeN(fs,36)
    {
        ;
    }
};

//-----------------------------------------------------------------------------
// info function: ChucK calls this when loading/probing the chugin
// NOTE: please customize these info fields below; they will be used for
// chugins loading, probing, and package management and documentation
//-----------------------------------------------------------------------------
CK_DLL_INFO( Encode )
{
    // the version string of this chugin, e.g., "v1.2.1"
    QUERY->setinfo( QUERY, CHUGIN_INFO_CHUGIN_VERSION, "" );
    // the author(s) of this chugin, e.g., "Alice Baker & Carl Donut"
    QUERY->setinfo( QUERY, CHUGIN_INFO_AUTHORS, "Everett M. Carpenter" );
    // text description of this chugin; what is it? what does it do? who is it for?
    QUERY->setinfo( QUERY, CHUGIN_INFO_DESCRIPTION, "Ambisonic encoding within ChucK" );
    // (optional) URL of the homepage for this chugin
    QUERY->setinfo( QUERY, CHUGIN_INFO_URL, "" );
    // (optional) contact email
    QUERY->setinfo( QUERY, CHUGIN_INFO_EMAIL, "" );
}


//-----------------------------------------------------------------------------
// query function: ChucK calls this when loading the chugin
// modify this function to define this chugin's API and language extensions
//-----------------------------------------------------------------------------
CK_DLL_QUERY( Encode )
{
    // generally, don't change this...
    QUERY->setname( QUERY, "Encode" );

    // ------------------------------------------------------------------------
    // begin class definition(s); will be compiled, verified,
    // and added to the chuck host type system for use
    // ------------------------------------------------------------------------
    // NOTE to create a non-UGen class, change the second argument
    // to extend a different ChucK class (e.g., "Object")
    QUERY->begin_class( QUERY, "Encode", "UGen" );
    
    //===============================================================    
    // register default constructor
    QUERY->add_ctor( QUERY, encode1_ctor );
    QUERY->add_arg(QUERY, "int", "order");
    // register the destructor
    QUERY->add_dtor( QUERY, encode1_dtor );
    // for UGens only: add tick function
    QUERY->add_ugen_func( QUERY, encode1_tickf, NULL, 1, 1 );
    // example of adding getter method
    QUERY->add_mfun(QUERY, encode1_getOrder, "float", "order");
    //===============================================================
    // register default constructor
    QUERY->add_ctor(QUERY, encode2_ctor);
    QUERY->add_arg(QUERY, "int", "order");
    // register the destructor
    QUERY->add_dtor(QUERY, encode2_dtor);
    // for UGens only: add tick function
    QUERY->add_ugen_func(QUERY, encode2_tickf, NULL, 1, 1);
    // example of adding getter method
    QUERY->add_mfun(QUERY, encode2_getOrder, "float", "order");
    //===============================================================
    // this reserves a variable in the ChucK internal class to store 
    // referene to the c++ class we defined above
    encode_data_offset = QUERY->add_mvar( QUERY, "int", "@e_data", false );

    // ------------------------------------------------------------------------
    // end the class definition
    // IMPORTANT: this MUST be called to each class definition!
    // ------------------------------------------------------------------------
    QUERY->end_class( QUERY );

    // wasn't that a breeze?
    return TRUE;
}

//===============================================================
// implementation for the default constructor
CK_DLL_CTOR( encode1_ctor )
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT( SELF, encode_data_offset ) = 0;
    
    // instantiate our internal c++ class representation
    Encode1 * e_obj = new Encode1( API->vm->srate(VM) );
    
    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT( SELF, encode_data_offset ) = (t_CKINT)e_obj;
}

// implementation for the destructor
CK_DLL_DTOR(encode1_dtor)
{
    // get our c++ class pointer
    EncodeN* e_obj = (EncodeN*)OBJ_MEMBER_INT(SELF, encode_data_offset);
    // clean up (this macro tests for NULL, deletes, and zeros out the variable)
    CK_SAFE_DELETE(e_obj);
    // set the data field to 0
    OBJ_MEMBER_INT(SELF, encode_data_offset) = 0;
}

// implementation for tick function (relevant only for UGens)
CK_DLL_TICK(encode1_tickf)
{
    // get our c++ class pointer
    EncodeN* e_obj = (EncodeN*)OBJ_MEMBER_INT(SELF, encode_data_offset);

    // invoke our tick function; store in the magical out variable
    if (e_obj) *out = e_obj->tickf(in, *out, 4);

    // yes
    return TRUE;
}

// example implementation for getter
CK_DLL_MFUN(encode1_getOrder)
{
    // get our c++ class pointer
    EncodeN* e_obj = (EncodeN*)OBJ_MEMBER_INT(SELF, encode_data_offset);

    // call getParam() and set the return value
    RETURN->v_float = e_obj->getOrder();
}

//===============================================================
// implementation for the default constructor
CK_DLL_CTOR(encode2_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, encode_data_offset) = 0;

    // instantiate our internal c++ class representation
    Encode2* e_obj = new Encode2(API->vm->srate(VM));

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, encode_data_offset) = (t_CKINT)e_obj;
}


// implementation for the destructor
CK_DLL_DTOR( encode2_dtor )
{
    // get our c++ class pointer
    EncodeN * e_obj = (EncodeN*)OBJ_MEMBER_INT( SELF, encode_data_offset );
    // clean up (this macro tests for NULL, deletes, and zeros out the variable)
    CK_SAFE_DELETE( e_obj );
    // set the data field to 0
    OBJ_MEMBER_INT( SELF, encode_data_offset ) = 0;
}

// implementation for tick function (relevant only for UGens)
CK_DLL_TICK(encode2_tickf)
{
    // get our c++ class pointer
    EncodeN* e_obj = (EncodeN*)OBJ_MEMBER_INT(SELF, encode_data_offset);

    // invoke our tick function; store in the magical out variable
    if (e_obj) *out = e_obj->tickf(in, *out, 9);

    // yes
    return TRUE;
}

// example implementation for getter
CK_DLL_MFUN(encode2_getOrder)
{
    // get our c++ class pointer
    EncodeN* e_obj = (EncodeN*)OBJ_MEMBER_INT(SELF, encode_data_offset);

    // call getParam() and set the return value
    RETURN->v_float = e_obj->getOrder();
}
//===============================================================
// implementation for the default constructor
CK_DLL_CTOR(encode3_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, encode_data_offset) = 0;

    // instantiate our internal c++ class representation
    Encode2* e_obj = new Encode2(API->vm->srate(VM));

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, encode_data_offset) = (t_CKINT)e_obj;
}


// implementation for the destructor
CK_DLL_DTOR(encode3_dtor)
{
    // get our c++ class pointer
    EncodeN* e_obj = (EncodeN*)OBJ_MEMBER_INT(SELF, encode_data_offset);
    // clean up (this macro tests for NULL, deletes, and zeros out the variable)
    CK_SAFE_DELETE(e_obj);
    // set the data field to 0
    OBJ_MEMBER_INT(SELF, encode_data_offset) = 0;
}

// implementation for tick function (relevant only for UGens)
CK_DLL_TICK(encode3_tickf)
{
    // get our c++ class pointer
    EncodeN* e_obj = (EncodeN*)OBJ_MEMBER_INT(SELF, encode_data_offset);

    // invoke our tick function; store in the magical out variable
    if (e_obj) *out = e_obj->tickf(in, *out, 16);

    // yes
    return TRUE;
}

// example implementation for getter
CK_DLL_MFUN(encode3_getOrder)
{
    // get our c++ class pointer
    EncodeN* e_obj = (EncodeN*)OBJ_MEMBER_INT(SELF, encode_data_offset);

    // call getParam() and set the return value
    RETURN->v_float = e_obj->getOrder();
}
//===============================================================
// implementation for the default constructor
CK_DLL_CTOR(encode4_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, encode_data_offset) = 0;

    // instantiate our internal c++ class representation
    Encode2* e_obj = new Encode2(API->vm->srate(VM));

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, encode_data_offset) = (t_CKINT)e_obj;
}


// implementation for the destructor
CK_DLL_DTOR(encode4_dtor)
{
    // get our c++ class pointer
    EncodeN* e_obj = (EncodeN*)OBJ_MEMBER_INT(SELF, encode_data_offset);
    // clean up (this macro tests for NULL, deletes, and zeros out the variable)
    CK_SAFE_DELETE(e_obj);
    // set the data field to 0
    OBJ_MEMBER_INT(SELF, encode_data_offset) = 0;
}

// implementation for tick function (relevant only for UGens)
CK_DLL_TICK(encode4_tickf)
{
    // get our c++ class pointer
    EncodeN* e_obj = (EncodeN*)OBJ_MEMBER_INT(SELF, encode_data_offset);

    // invoke our tick function; store in the magical out variable
    if (e_obj) *out = e_obj->tickf(in, *out, 25);

    // yes
    return TRUE;
}

// example implementation for getter
CK_DLL_MFUN(encode4_getOrder)
{
    // get our c++ class pointer
    EncodeN* e_obj = (EncodeN*)OBJ_MEMBER_INT(SELF, encode_data_offset);

    // call getParam() and set the return value
    RETURN->v_float = e_obj->getOrder();
}
//===============================================================
// implementation for the default constructor
CK_DLL_CTOR(encode5_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, encode_data_offset) = 0;

    // instantiate our internal c++ class representation
    Encode2* e_obj = new Encode2(API->vm->srate(VM));

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, encode_data_offset) = (t_CKINT)e_obj;
}


// implementation for the destructor
CK_DLL_DTOR(encode5_dtor)
{
    // get our c++ class pointer
    EncodeN* e_obj = (EncodeN*)OBJ_MEMBER_INT(SELF, encode_data_offset);
    // clean up (this macro tests for NULL, deletes, and zeros out the variable)
    CK_SAFE_DELETE(e_obj);
    // set the data field to 0
    OBJ_MEMBER_INT(SELF, encode_data_offset) = 0;
}

// implementation for tick function (relevant only for UGens)
CK_DLL_TICK(encode5_tickf)
{
    // get our c++ class pointer
    EncodeN* e_obj = (EncodeN*)OBJ_MEMBER_INT(SELF, encode_data_offset);

    // invoke our tick function; store in the magical out variable
    if (e_obj) *out = e_obj->tickf(in, *out, 36);

    // yes
    return TRUE;
}

// example implementation for getter
CK_DLL_MFUN(encode5_getOrder)
{
    // get our c++ class pointer
    EncodeN* e_obj = (EncodeN*)OBJ_MEMBER_INT(SELF, encode_data_offset);

    // call getParam() and set the return value
    RETURN->v_float = e_obj->getOrder();
}
//===============================================================